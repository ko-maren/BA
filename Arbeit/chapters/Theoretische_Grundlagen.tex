\chapter{Theoretische Grundlagen} \label{sec:grund}
Zu Beginn sollen einige Grundlagen näher erläutert werden, die zum Erstellen der Arbeit essenziell waren.

\section{Linux - Kernel und Userspace}\label{sec:linux}
Da das Zielsystem auf Linux läuft, soll zunächst dieses Betriebssystem betrachtet werden. 
Im Herbst 1991 wurde die erste Version des Systems von Linus Torvalds veröffentlicht und der Gründer kümmert sich, mit Unterstützung, weiterhin um die Entwicklung des frei verfügbaren Betriebssystem.
 
Der Name Linux bezeichnet dabei eigentlich nur den Kern des Systems, auch Kernel genannt. Zusätzlich benötigt man noch System- und Anwendersoftware. Oft wird dieser Teil als Userspace zusammengefasst. \citep[S. 46]{plotner2012linux} 

Der Kernel hat verschiedene Aufgaben. Unter anderem ist er für die Prozess- und die Speicherverwaltung sowie das Gerätemanagement zuständig. \citep[S. 234]{schroder2009embedded} 

Im Normalfall hat der Nutzer aus dem Userspace keinen direkten Zugriff auf die Kernelfunktionen und der Hardware. Nur über Systemaufrufe, auch Syscalls, hat ein Programm im Userspace die Möglichkeit Änderungen an der Hardware zu kommunizieren beziehungsweise bestimmte Funktionen im Kernel zu nutzen. \citep[S. 124]{plotner2012linux} 
Die Brücke zwischen der Hardware und dem Benutzer stellt somit der Kernel da.


\section{\acl{ioctl}}\label{sec:ioctl_t}
Um ein zuverlässig arbeitendes Betriebssystem zu haben, muss der Speicherbereich von Kernel und Userspace getrennt sein. \citep[S. 232]{schroder2009embedded}
Damit entsteht die Notwenigkeit zwischen Userspace und Kernel Daten auszutauschen. Die Anwendungen im Userspace können über das sogenannte Systemcall Interface auf die Funktionen im Kernel zugreifen. In einer Struktur vom Typ file\_operations wird die Schnittstelle zu einem Treiber vorgegeben. In dieser Struktur werden treiberabhängige Funktionszeiger gespeichert. \citep[S. 249]{schroder2009embedded}

Im folgenden soll lediglich der Zeiger auf das \acf{ioctl} betrachtet werden, da dieser im weiteren Teil der Arbeit eine wichtige Rolle spielt.
Durch die \ac{ioctl} Methode wird dem Programmierer ein flexibles Werkzeug zur Verfügung gestellt. 

%todo linux kernel code
\begin{minipage}{\textwidth}
\begin{bash}
int (*ioctl) (struct inode *node, struct file *instanz, unsigned int cmd, unsigned long arg);
\end{bash}
\captionof{floatcode}{Funktionsdeklaration des \ac{ioctl} in der file\_operations Struktur}
\end{minipage}

Über die \textit{node} wird der Dateideskriptor und über \textit{instanz} ein Zeiger auf die Treiberinstanz an den Funktionszeiger übergeben. Das Kommando wird durch eine Nummer widergespiegelt und ist in der Funktionsdeklaration als \textit{cmd} zu finden. Das optionale Argument \textit{arg} wird meistens als Zeiger auf eine Dateistruktur, welche kopiert werden soll angegeben. \citep[S. 90f]{corbet2005linux}

Mit den Übergabeparametern und dem Dateideskriptor wird die Funktion dann in Anwendungen im Userspace aufgerufen, im Kernel werden die Daten weiterverarbeitet und wieder zurück gegeben.

\section{Datenaustausch zwischen Kernel und Userspace}
Im vorausgegangen Kapitel wurde schon die Notwendigkeit von getrennten Speicherbereichen des Kernels und des Userspaces erläutert. 
Dadurch wird der Datenaustausch zwischen den beiden Ebenen natürlich schwieriger. Durch \textit{copy\_from\_user} beziehungsweise \textit{copy\_to\_user} stehen im Linuxkernel zwei Funktionen als hilfreiche Werkzeuge für diesen Austausch zu Verfügung.

%todo linux kernel code & Unterschrift
\begin{minipage}{\textwidth}
\begin{bash}
unsigned long copy from user(void *to, const void *from, unsigned long num);
unsigned long copy to user(void *to, const void *from, unsigned long num);
\end{bash}
\captionof{floatcode}{Funktionsdeklaration in asm/uaccess.h}
\end{minipage}

Die Hauptaufgabe beider Funktionen ist das Kopieren von Daten, zusätzlich werden die übergebenen Speicherbereiche auf Gültigkeit überprüft. 
In der \textit{copy\_from\_user} werden die Daten ab \textit{from} aus dem Userspace mit der Größe von \textit{num} Bytes an die Stelle \textit{to} in den Kernel kopiert.
Analog arbeitet das Gegenstück \textit{copy\_to\_user}. Hier gibt \textit{from} allerdings die Speicherstelle im Kernel an und somit ist \textit{to} die Stelle im Userspace.
Im Erfolgsfall geben beide Funktionen 0 zurück, andernfalls wird die Anzahl der nicht kopierten Bytes zurückgegeben. \citep[S. 250f]{schroder2009embedded}

%todo minor and major id

\section{Plattformtreiber}\label{sec:plat_t}
Gerätetreiber, und damit auch Plattformtreiber, sind unter Linux im Kernel angesiedelt. Eigene Treiber werden hierzu meist modular entwickelt und nicht fest in den Kernel integriert. Allerdings muss auch der Programmierer bei den nachgeladenen Kernelmodulen auf die korrekte Nutzung des Speicherplatzes achten, da diese Module ebenfalls im Kernel laufen und somit ein Segmentierungsfehler schwerwiegende Folgen hätte. \citep[S. 231ff.]{schroder2009embedded}

Damit die Treiber richtig funktionieren werden müssen gibt es einige Bestandteile, die in jedem Modul wiederzufinden sind. Standardmäßig wird die Registrierung von Treiber und Device an unterschiedlichen Teilen des Programms ausgeführt. \cite{corbetplatform} 

Jedes Kernelmodule besitzt mindestens eine init und exit Funktion. Hierzu gibt es im Kernel eigene Makros, in welchen die Funktionen übergeben werden. Der Aufruf ist dann entweder beim Kernelboot bzw. beim Laden des Modules oder beim Entfernen des Treibers.
%todo linux kernel zitieren!
(https://elixir.bootlin.com/linux/v4.15.9/source/include/linux/module.h ab Zeile 77)

%todo linux kernel code & Unterschrift
\begin{minipage}{\textwidth}
	\begin{bash}
struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t state);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
};
	\end{bash}
	\captionof{floatcode}{Struktur in linux/platform\_device.h}
\end{minipage}

Nachdem der entsprechende Treiber geladen ist und das Plattformgeräte registriert wurde, wird die .probe Funktion aufgerufen. Dort wird dann eine Instanz des Devices erzeugt. Analog dazu gibt es die .remove Funktion, hier wird die Instanz entsprechend wieder aufgelöst. \cite{corbetplatform} 

%todo umformulieren & kapitel zitieren
Beim Anlegen der Instanz kann ein Zeiger auf ein struct übergeben werden, in welchem Daten übergeben werden. In der probe Funktion sind somit spezielle Daten für ein entsprechendes Device vorhanden. \cite{corbetplatform} 

\section{\acl{mfd}}\label{sec:mfd_t}
%todo definition mfd quelle
Normalerweise wird lediglich ein Device angelegt, ohne weitere Unterteilungen zu machen. Es ist allerdings möglich unter einem Parentdevice noch weitere Childdevices zu registrieren. Diese Art wird dann \acf{mfd} genannt.

%todo linux kernel code & Unterschrift
\begin{minipage}{\textwidth}
	\begin{bash}
extern int devm_mfd_add_devices(struct device *dev, int id, 
		const struct mfd_cell *cells, int n_devs, 
		struct resource *mem_base, int irq_base, 
		struct irq_domain *irq_domain);
	\end{bash}
	\captionof{floatcode}{Funktionsdeklaration in mfd/core.h}
\end{minipage}

Durch die obere Funktion werden alle Childdevices automatisch entfernt, wenn diese aufgelöst werden.

Als ersten Parameter ein Zeiger auf das Parentdevice übergeben. \textit{mfd\_cell} ist eine Struktur, welche das Childdevice näher beschreibt und über die \textit{n\_devs} wird die Anzahl der zu registrierenden Childdevices übergeben. Die anderen Übergabeparameter werden nicht näher betrachtet, da sie im folgenden nicht benötigt werden. 
(https://elixir.bootlin.com/linux/v5.2.14/source/drivers/mfd/mfd-core.c)




